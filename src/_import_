################################################################################
######################## Definitions of user variables #########################
################################################################################


################################################################################
######################## Definitions of user functions #########################
################################################################################

# ``````````````````````````````````````````````````````````````````````````````
# Function name: InitPv()
#
# Description:
#   Initialization of the environment for other functions.
#
# Usage:
#   InitPv "param_0" "param_1"
#
# Examples:
#   InitPv _conn_params[@] _hypervisor_params[@]
#

function InitPv() {

  local _FUNCTION_ID="InitPv"
  local _STATE=0

  local _conn_params=("${!1}")
  local _hypervisor_params=("${!2}")

  local _host="${_conn_params[0]}"
  local _port="${_conn_params[1]}"

  local _vm_type="${_hypervisor_params[0]}"
  local _vm_storage_r="${_hypervisor_params[1]}"
  local _vm_id="${_hypervisor_params[2]}"
  local _vm_name="${_hypervisor_params[3]}"
  local _vm_storage_l="${_hypervisor_params[4]}"
  local _vm_pv_storage_l="${_hypervisor_params[5]}"
  local _vm_pv_lvm_l="${_hypervisor_params[6]}"
  local _vm_pv_id_l="${_hypervisor_params[7]}"
  local _vm_pv_disk_format="${_hypervisor_params[8]}"
  local _vm_pv_disk_sync="${_hypervisor_params[9]}"
  local _vm_pv_disk_sync_host="${_hypervisor_params[10]}"

  local _remote_path="${_vm_storage_r}/${_vm_name}"
  local _local_path="${_vm_storage_l}/${_host}/${_vm_name}"
  local _local_path_pv="${_vm_pv_storage_l}/${_vm_pv_id_l}"

  # Functions stack description:
  #   CheckConn       - check the connection to the server (xen/vmware)
  #   InitRemoteEnv   - creates a remote environment (xen/vmware)
  #   CheckRemoteEnv  - checks a remote environment (xen/vmware)
  #   VmExport        - export Virtual Machine (xen)
  #   VmCopy          - copy Virtual Machine (xen/vmware)
  #   VmExtract       - extract Virtual Machine disks (xen)
  #   VmConvertDisks  - convert Virtual Machine (xen/vmware)
  #   VmImport        - import Virtual Machine (xen/vmware)

  if [[ "$_vm_type" == "xen" ]] ; then

    local _function_stack=(CheckConn InitRemoteEnv CheckRemoteEnv VmExport VmCopy VmExtract VmConvertDisks)

  elif [[ "$_vm_type" == "vmware" ]] ; then

    local _function_stack=(CheckConn InitRemoteEnv CheckRemoteEnv VmCopy VmConvertDisks)

  else

    _sprintf "stop" "incorrectly set hypervisor type (properly: xen or vmware)"

    _logger "stop" \
      "${_FUNCTION_ID}()" \
      "incorrectly set hypervisor type (properly: xen or vmware)"

  fi

  # We start the synchronization function when calling the -s|--sync option.
  if [[ "$_vm_pv_disk_sync" == "true" ]] ; then

    _function_stack+=(VmImport)

  else

    _vm_pv_disk_sync="false"
    _vm_pv_disk_sync_host="local"

  fi

  _sprintf "head" "creating and checking local environment"

  _logger "head" \
    "${_FUNCTION_ID}()" \
    "creating and checking local environment"

  # Display of variable values without checking them.
  for i in "_host" \
           "_port" \
           "_vm_type" \
           "_vm_id" \
           "_vm_name" \
           "_remote_path" \
           "_local_path" \
           "_vm_pv_storage_l" \
           "_vm_pv_lvm_l" \
           "_vm_pv_id_l" \
           "_vm_pv_disk_format" \
           "_vm_pv_disk_sync" \
           "_vm_pv_disk_sync_host" ; do

    eval _i='$'${i}

    _sprintf "info" "${i}: '${_i}'"

    _logger "info" \
      "${_FUNCTION_ID}()" \
      "${i}: '$_i'"

    # First, we check the virtual machine ID and its numeric value.
    local _num='^[0-9]+$'
    if [[ "$i" == "_vm_pv_id_l" ]] ; then

      if [[ "$_vm_pv_id_l" =~ $_num ]] ; then

        # If the value is a number then we check whether
        # the virtual machine with that identifier exists in the proxmox cluster.
        if [[ ! $(grep "qemu" /etc/pve/.vmlist | cut -d ":" -f1 | grep "$_vm_pv_id_l") ]] ; then

          _sprintf "stop" "vm with this id does not exist"

          _logger "stop" \
            "${_FUNCTION_ID}()" \
            "vm with this id does not exist"

        fi

      else

        _sprintf "stop" "_vm_pv_id_l variable has no numeric value"

        _logger "stop" \
          "${_FUNCTION_ID}()" \
          "_vm_pv_id_l variable has no numeric value"

      fi

    fi

    # Checking variable values (if they are incorrect values).
    if [[ ! -d "$_vm_pv_storage_l" ]] || \
       [[ ! -e "$_vm_pv_lvm_l" ]] ; then

      _sprintf "stop" "value: incorrect"

      _logger "stop" \
        "${_FUNCTION_ID}()" \
        "value: incorrect"

    fi

  done

  for i in "${_function_stack[@]}" ; do $i ; if [ ! $? ] ; then _exit_ 255 ; fi ; done

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: CheckConn()
#
# Description:
#   Validates the connection to the remote server.
#
# Usage:
#   CheckConn
#
# Examples:
#   CheckConn
#

function CheckConn() {

  local _FUNCTION_ID="CheckConn"
  local _STATE=0

  _sprintf "head" "checking connection to remote host"

  _logger "head" \
    "${_FUNCTION_ID}()" \
    "checking connection to remote host"

  local _arg=(\
  "host: '${_host}'"^"eval timeout 1 bash -c \"</dev/tcp/${_host}/${_port}\"")

  if [[ "$_vm_pv_disk_sync_host" != "local" ]] ; then

    _arg+=(\
    "host: '${_vm_pv_disk_sync_host}'"^"eval timeout 1 bash -c \"</dev/tcp/${_vm_pv_disk_sync_host}/${_port}\"")

  fi

  for i in "${_arg[@]}" ; do

    _msg="${i%%^*}"
    _full_command="${i#*^}"

    _sprintf "info" "$_msg"

    _logger "info" \
      "${_FUNCTION_ID}()" \
      "$_msg"

    _init_cmd "$_full_command" ; if [ ! $? ] ; then _STATE=$? ; fi

  done

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: InitRemoteEnv()
#
# Description:
#   Initialization of the remote environment.
#
# Usage:
#   InitRemoteEnv
#
# Examples:
#   InitRemoteEnv
#

function InitRemoteEnv() {

  local _FUNCTION_ID="InitRemoteEnv"
  local _STATE=0

  _sprintf "head" "preparing remote environment"

  _logger "head" \
    "${_FUNCTION_ID}()" \
    "preparing remote environment"

  local _arg=(\
  "resetting '$_pv_vars'"^"ssh ${_host} -p ${_port} >${_pv_vars}")

  for i in "${_arg[@]}" ; do

    _msg="${i%%^*}"
    _full_command="${i#*^}"

    _sprintf "info" "$_msg"

    _logger "info" \
      "${_FUNCTION_ID}()" \
      "$_msg"

    _init_cmd "$_full_command" ; if [ ! $? ] ; then _STATE=$? ; fi

  done

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: CheckRemoteEnv()
#
# Description:
#   Checks of the remote environment.
#
# Usage:
#   CheckRemoteEnv
#
# Examples:
#   CheckRemoteEnv
#

function CheckRemoteEnv() {

  local _FUNCTION_ID="CheckRemoteEnv"
  local _STATE=0

  _sprintf "head" "checking remote environment"

  _logger "head" \
    "${_FUNCTION_ID}()" \
    "checking remote environment"

  if [[ "$_vm_type" == "xen" ]] ; then

    local _arg=(\
    "directory: '${_vm_storage_r}'"^"ssh ${_host} -p ${_port} if [[ ! -d \"${_vm_storage_r}\" ]] ; then exit 1 ; fi" \
    "vm: '${_vm_id}'"^"ssh ${_host} -p ${_port} if [[ ! \$(xe vm-list | grep ${_vm_id}) ]] ; then exit 1 ; fi")

  elif [[ "$_vm_type" == "vmware" ]] ; then

    local _arg=(\
    "directory: '${_vm_storage_r}'"^"ssh ${_host} -p ${_port} if [[ ! -d \"${_vm_storage_r}\" ]] ; then exit 1 ; fi" \
    "vm: '${_vm_id}'"^"ssh ${_host} -p ${_port} if [[ ! \$(vim-cmd vmsvc/getallvms | grep ${_vm_id}) ]] ; then exit 1 ; fi" \
    "vm directory: '${_remote_path}'"^"ssh ${_host} -p ${_port} if [[ ! -d \"${_remote_path}\" ]] ; then exit 1 ; fi")

  fi

  for i in "${_arg[@]}" ; do

    _msg="${i%%^*}"
    _full_command="${i#*^}"

    _sprintf "info" "$_msg"

    _logger "info" \
      "${_FUNCTION_ID}()" \
      "$_msg"

    _init_cmd "$_full_command" ; if [ ! $? ] ; then _STATE=$? ; fi

  done

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: VmExport()
#
# Description:
#   Exports the virtual machine.
#
# Usage:
#   VmExport
#
# Examples:
#   VmExport
#

function VmExport() {

  local _FUNCTION_ID="VmExport"
  local _STATE=0

  _sprintf "head" "exporting $_vm_id"

  _logger "info" \
    "${_FUNCTION_ID}()" \
    "exporting $_vm_id"

  local _arg=(\
  "creating snapshot: '${_vm_name}-${_random}'"^"ssh ${_host} -p ${_port} _id=\$(xe vm-snapshot vm=${_vm_id} new-name-label=${_vm_name}-${_random}) ; echo id=\$_id >> ${_pv_vars}" \
  "exporting snapshot: '${_vm_name}.ova'"^"ssh ${_host} -p ${_port} _id=\$(cat ${_pv_vars} | grep id= | cut -d = -f2) ; xe vm-export vm=\${_id} filename=${_vm_storage_r}/${_vm_name}.ova")

  for i in "${_arg[@]}" ; do

    _msg="${i%%^*}"
    _full_command="${i#*^}"

    _sprintf "info" "$_msg"

    _logger "info" \
      "${_FUNCTION_ID}()" \
      "$_msg"

    _init_cmd "$_full_command" ; if [ ! $? ] ; then _STATE=$? ; fi

  done

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: VmCopy()
#
# Description:
#   Copies the virtual machine from remote host to local (target) host.
#
# Usage:
#   VmCopy
#
# Examples:
#   VmCopy
#

function VmCopy() {

  local _FUNCTION_ID="VmCopy"
  local _STATE=0

  _sprintf "head" "copying a virtual machine disks"

  _logger "info" \
    "${_FUNCTION_ID}()" \
    "copying a virtual machine disks"

  if [[ ! -d "$_local_path" ]] ; then

    _sprintf "info" "create a local directory: '$_local_path'"

    _logger "info" \
      "${_FUNCTION_ID}()" \
      "create a local directory: '$_local_path'"

    mkdir -p "$_local_path"

  fi

  if [[ "$_vm_type" == "xen" ]] ; then

    local _arg=(\
    "src: '${_vm_name}.ova', dst path: '${_local_path}'"^"scp -P ${_port} ${_host}:${_vm_storage_r}/${_vm_name}.ova ${_local_path}")

  elif [[ "$_vm_type" == "vmware" ]] ; then

    local _arg=(\
    "config file: '${_vm_id}.vmx', dst path: '${_local_path}'"^"scp -P ${_port} ${_host}:${_vm_storage_r}/${_vm_name}/${_vm_id}.vmx ${_local_path}" \
    "src: '*.vmdk', dst path: '${_local_path}'"^"scp -P ${_port} ${_host}:${_vm_storage_r}/${_vm_name}/*.vmdk ${_local_path}")

  fi

  for i in "${_arg[@]}" ; do

    _msg="${i%%^*}"
    _full_command="${i#*^}"

    _sprintf "info" "$_msg"

    _logger "info" \
      "${_FUNCTION_ID}()" \
      "$_msg"

    _init_cmd "$_full_command" ; if [ ! $? ] ; then _STATE=$? ; fi

  done

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: VmExtract()
#
# Description:
#   Extracts the virtual machine disks.
#
# Usage:
#   VmExtract
#
# Examples:
#   VmExtract
#

function VmExtract() {

  local _FUNCTION_ID="VmExtract"
  local _STATE=0

  _sprintf "head" "extracting ova files"

  _logger "info" \
    "${_FUNCTION_ID}()" \
    "extracting ova files"

  local _arg=(\
  "src: '${_vm_name}.ova', dst path: '${_local_path}'"^"tar xf ${_local_path}/${_vm_name}.ova -C ${_local_path}")

  if [[ "$l_remove_unused" == "yes" ]] ; then

    # We're checking to make sure there is.
    if [[ -e "${_local_path}/${_vm_name}.ova" ]] ; then
    
      _arg+=(\
      "remove: '${_vm_name}.ova'"^"rm -fr ${_local_path}/${_vm_name}.ova")

    fi

  fi

  for i in "${_arg[@]}" ; do

    _msg="${i%%^*}"
    _full_command="${i#*^}"

    _sprintf "info" "$_msg"

    _logger "info" \
      "${_FUNCTION_ID}()" \
      "$_msg"

    _init_cmd "$_full_command" ; if [ ! $? ] ; then _STATE=$? ; fi

  done

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: VmConvertDisks()
#
# Description:
#   Converts the virtual machine disks.
#
# Usage:
#   VmConvertDisks
#
# Examples:
#   VmConvertDisks
#

function VmConvertDisks() {

  local _FUNCTION_ID="VmConvertDisks"
  local _STATE=0

  _sprintf "head" "converting disks to $_vm_pv_disk_format format"

  _logger "info" \
    "${_FUNCTION_ID}()" \
    "converting disks to $_vm_pv_disk_format format"

  local _arg=()

  cd ${_local_path}

  if [[ "$_vm_type" == "xen" ]] ; then

    for _fda in $(find . -type d -name "Ref:*" -printf '%P\n') ; do

      _name=$(echo ${_fda} | tr ":" "_")

      _arg+=(\
      "src: '${_fda}', dst: '${_local_path}/${_name}.img'"^"xenmigrate --convert=${_fda} ${_name}.img")

      if [[ "$_vm_pv_disk_format" == "qcow2" ]] ; then

        _fdb="${_name}.img"
        _nname="${_fdb%.*}"

        _arg+=(\
        "src: '${_fdb}', dst: '${_local_path}/${_nname}.qcow2'"^"qemu-img convert -f raw -O qcow2 ${_fdb} ${_nname}.qcow2")

      fi

      if [[ "$l_remove_unused" == "yes" ]] ; then

        # We're checking to make sure there is.
        if [[ -e "${_fda}" ]] ; then
    
          _arg+=(\
          "remove: '${_fda}'"^"rm -fr ${_fda}")

          if [[ -e "${_fdb}" ]] ; then

            _arg+=(\
            "remove: '${_fdb}'"^"rm -fr ${_fdb}")

          fi

        fi

      fi

    done

  elif [[ "$_vm_type" == "vmware" ]] ; then

    local _vmdk_order=$(grep ".vmdk" "${_vm_id}.vmx" | cut -d "\"" -f2)

    # for _fda in $(find . -type f -name "*.vmdk" -printf '%P\n') ; do
    for _fda in $_vmdk_order ; do

      if [[ "$_fda" != *"flat"* ]] ; then

        _name="${_fda%.*}"

        if [[ "${_vm_pv_disk_format}" == "qcow2" ]] ; then

          _arg+=(\
          "src: '${_fda}', dst: '${_local_path}/${_name}.qcow2'"^"qemu-img convert -f vmdk -O qcow2 ${_fda} ${_name}.qcow2")

        elif [[ "${_vm_pv_disk_format}" == "img" ]] ; then

        _arg+=(\
        "src: '${_fda}', dst: '${_local_path}/${_name}.img'"^"qemu-img convert -f vmdk -O raw ${_fda} ${_name}.img")

        fi

        if [[ "$l_remove_unused" == "yes" ]] ; then

          # We're checking to make sure there is.
          if [[ -e "${_fda}" ]] ; then
    
            _arg+=(\
            "remove: '${_fda}'"^"rm -fr ${_fda}")

            if [[ -e "${_name}-flat.vmdk" ]] ; then

              _arg+=(\
              "remove: '${_name}-flat.vmdk"^"rm -fr ${_name}-flat.vmdk")

            fi

          fi

        fi

      fi

    done

  fi

  for i in "${_arg[@]}" ; do

    _msg="${i%%^*}"
    _full_command="${i#*^}"

    _sprintf "info" "$_msg"

    _logger "info" \
      "${_FUNCTION_ID}()" \
      "$_msg"

    _init_cmd "$_full_command" ; if [ ! $? ] ; then _STATE=$? ; fi

  done

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: VmImport()
#
# Description:
#   Imports the virtual machine.
#
# Usage:
#   VmImport
#
# Examples:
#   VmImport
#

function VmImport() {

  local _FUNCTION_ID="VmImport"
  local _STATE=0

  _sprintf "head" "importing a virtual machine disks"

  _logger "info" \
    "${_FUNCTION_ID}()" \
    "importing a virtual machine disks"

  local _arg=()
  local _x=1

  cd ${_local_path}

  for _fda in $(find . -type f -name "*.$_vm_pv_disk_format" -printf '%P\n') ; do
  
    if [[ "$_vm_pv_disk_format" == "img" ]] ; then

      local _vm_pv_local="${_vm_pv_lvm_l}/vm-${_vm_pv_id_l}-disk-${_x}"

      if [[ "$_vm_pv_disk_sync_host" == "local" ]] || [[ "$_vm_pv_disk_sync_host" == "$_host" ]] ; then

        _arg+=(\
        "checking: '${_vm_pv_local}'"^"eval if [[ ! -e ${_vm_pv_local} ]] ; then exit 1 ; fi" \
        "src: '${_fda}', dst path: '${_vm_pv_local}'"^"dd if=${_fda} of=${_vm_pv_local}")

      elif [[ "$_vm_pv_disk_sync_host" != "local" ]] && [[ "$_vm_pv_disk_sync_host" != "$_host" ]] ; then

        _arg+=(\
        "checking: '${_vm_pv_disk_sync_host}:${_vm_pv_local}'"^"ssh ${_vm_pv_disk_sync_host} -p ${_port} if [[ ! -e \"${_vm_pv_local}\" ]] ; then exit 1 ; fi" \
        "src: '${_fda}', dst path: '${_vm_pv_disk_sync_host}:${_vm_pv_local}'"^"eval dd if=${_fda} bs=4096 | ssh ${_vm_pv_disk_sync_host} -p ${_port} dd of=${_vm_pv_local} bs=4096")

      fi

      if [[ "$l_remove_unused" == "yes" ]] ; then

        # We're checking to make sure there is.
        if [[ -e "${_fda}" ]] ; then
    
          _arg+=(\
          "remove: '${_fda}'"^"rm -fr ${_fda}")

        fi

      fi

    elif [[ "$_vm_pv_disk_format" == "qcow2" ]] ; then

      local _vm_pv_local="${_local_path_pv}/vm-${_vm_pv_id_l}-disk-${_x}.qcow2"

      if [[ "$_vm_pv_disk_sync_host" == "local" ]] || [[ "$_vm_pv_disk_sync_host" == "$_host" ]] ; then

        _arg+=(\
        "checking: '${_vm_pv_local}'"^"eval if [[ ! -e ${_vm_pv_local} ]] ; then exit 1 ; fi" \
        "src: '${_fda}', dst path: '${_vm_pv_local}'"^"cp ${_fda} ${_vm_pv_local}")

      elif [[ "$_vm_pv_disk_sync_host" != "local" ]] && [[ "$_vm_pv_disk_sync_host" != "$_host" ]] ; then

        _arg+=(\
        "checking: '${_vm_pv_disk_sync_host}:${_vm_pv_local}'"^"ssh ${_vm_pv_disk_sync_host} -p ${_port} if [[ ! -e \"${_vm_pv_local}\" ]] ; then exit 1 ; fi" \
        "src: '${_fda}', dst path: '${_vm_pv_disk_sync_host}:${_vm_pv_local}'"^"scp ${_fda} -P ${_port} ${_vm_pv_disk_sync_host}:${_vm_pv_local}")

      fi

      if [[ "$l_remove_unused" == "yes" ]] ; then

        # We're checking to make sure there is.
        if [[ -e "${_fda}" ]] ; then
    
          _arg+=(\
          "remove: '${_fda}'"^"rm -fr ${_fda}")

        fi

      fi

    fi

    _x=$((_x + 1))

  done

  for i in "${_arg[@]}" ; do

    _msg="${i%%^*}"
    _full_command="${i#*^}"

    _sprintf "info" "$_msg"

    _logger "info" \
      "${_FUNCTION_ID}()" \
      "$_msg"

    _init_cmd "$_full_command" ; if [ ! $? ] ; then _STATE=$? ; fi

  done

  return $_STATE

}
