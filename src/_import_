#!/usr/bin/env bash

################################################################################
######################## Definitions of user variables #########################
################################################################################


################################################################################
######################## Definitions of user functions #########################
################################################################################

# ``````````````````````````````````````````````````````````````````````````````
# Function name: InitEnv()
#
# Description:
#   Initialization of the environment for other functions.
#
# Usage:
#   InitEnv
#
# Examples:
#   InitEnv
#

function InitEnv() {

  local _FUNCTION_ID="InitEnv"
  local _STATE=0

  _sprintf "head" "creating and checking configuration of local environment"

  _logger "head" \
    "${_FUNCTION_ID}()" \
    "creating and checking configuration of local environment"

  # Display of variable values without checking them.
  for i in "hv_type" \
           "hv_host" \
           "vm_id" \
           "vm_name" \
           "pve_id" \
           "pve_format" \
           "hv_storage" \
           "local_storage" \
           "pve_storage" \
           "pve_lvm" \
           "pve_import" \
           "pve_host" \
           "re_path" \
           "lo_path" \
           "port" \
           "ssh_opt" \
           "dd_opt" ; do

    _i="" ; eval _i='$'$i

    local _num='^[0-9]+$'

    # shellcheck disable=SC2154
    # Checking variable values (if they are incorrect values).
    case $i in

      hv_type)

        if [[ "$hv_type" != "vmware" ]] && [[ "$hv_type" != "xen" ]] ; then

          _sprintf "stop" "hv_type: incorrectly set hypervisor type (properly: 'xen' or 'vmware')"

          _logger "stop" \
            "${_FUNCTION_ID}()" \
            "hv_type: incorrectly set hypervisor type (properly: 'xen' or 'vmware')"

        fi

      ;;

      pve_id)

        # We check the virtual machine ID and its numeric value.
        if [[ "$i" == "pve_id" ]] ; then

          if [[ "$pve_id" =~ $_num ]] ; then

            # shellcheck disable=SC2143
            # If the value is a number then we check whether
            # the virtual machine with that identifier exists in the proxmox cluster.
            if [[ ! $(grep "qemu" /etc/pve/.vmlist | cut -d ":" -f1 | grep "$pve_id") ]] ; then

              _sprintf "stop" "pve_id: vm with this id does not exist"

              _logger "stop" \
                "${_FUNCTION_ID}()" \
                "pve_id: vm with this id does not exist"

            fi

          else

            _sprintf "stop" "pve_id: vm id has no numeric value"

            _logger "stop" \
              "${_FUNCTION_ID}()" \
              "pve_id: vm id has no numeric value"

          fi

        fi

      ;;

      pve_format)

        if [[ "$pve_format" != "img" ]] && [[ "$pve_format" != "qcow2" ]] ; then

          _sprintf "stop" "pve_format: incorrectly set format type (properly: 'img' or 'qcow2')"

          _logger "stop" \
            "${_FUNCTION_ID}()" \
            "pve_format: incorrectly set format type (properly: img or qcow2)"

        fi

      ;;

      pv_import)

        # We start the import when calling the --import option.
        if [[ "$pve_import" != "true" ]] ; then

          pve_import="false"
          pve_host="local"

        fi

      ;;

      lo_path)

        if [[ ! -d "$lo_path" ]] ; then

          _sprintf "info" "lo_path: creating a local directory: '$lo_path'"

          _logger "info" \
            "${_FUNCTION_ID}()" \
            "lo_path: creating a local directory: '$lo_path'"

          mkdir -p "$lo_path"

        fi

      ;;

      pve_storage)

        if [[ ! -d "$pve_storage" ]] ; then

          _sprintf "stop" "pve_storage: incorrectly set storage (does not exist?)"

          _logger "stop" \
            "${_FUNCTION_ID}()" \
            "pve_storage: incorrectly set storage (does not exist?)"

        fi

      ;;

      pve_lvm)

        if [[ ! -e "$pve_lvm" ]] ; then

          _sprintf "stop" "pve_lvm: incorrectly set lvm (does not exist?)"

          _logger "stop" \
            "${_FUNCTION_ID}()" \
            "pve_lvm: incorrectly set lvm (does not exist?)"

        fi

      ;;

    esac

    _sprintf "info" "${i}: '$_i'"

    _logger "info" \
      "${_FUNCTION_ID}()" \
      "${i}: '$_i'"

  done

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: InitPv()
#
# Description:
#   Validates the connection to the remote server.
#
# Usage:
#   InitPv
#
# Examples:
#   InitPv
#

function InitPv() {

  local _FUNCTION_ID="InitPv"
  local _STATE=0

  local _args=("$@")

  _logger "info" \
    "${_FUNCTION_ID}()" \
    "init function: '${_args[@]}'"

  # In these two variables we store the message to display
  # and the command to execute.
  export _msg_args=()
  export _cmd_args=()

  eval "${_args[@]}" ; if [ ! $? ] ; then _exit_ 255 ; fi

  _num=${#_msg_args[@]}
  for (( _xa=0 ; _xa<=((_num - 1)) ; _xa++ )) ; do

    _msg="${_msg_args[$_xa]}"
    _full_command="${_cmd_args[$_xa]}"

    _sprintf "info" "$_msg"

    _logger "info" \
      "${_FUNCTION_ID}()" \
      "$_msg"

    _init_cmd "$_full_command" ; if [ ! $? ] ; then _exit_ 255 ; fi

  done

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: CheckConn()
#
# Description:
#   Validates the connection to the remote server.
#
# Usage:
#   CheckConn
#
# Examples:
#   CheckConn
#

function CheckConn() {

  local _FUNCTION_ID="CheckConn"
  local _STATE=0

  local _host="$1"
  local _port="$2"

  # We test two types of connections that will be used.
  _msg_args+=(\
  "host (tcp): '${_host}'" \
  "host (ssh): '${_host}'")

  _cmd_args+=(\
  "eval timeout 1 bash -c \"</dev/tcp/${_host}/${_port}\"" \
  "ssh ${ssh_opt} ${_host} -p ${_port} exit 0")

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: CheckStorage()
#
# Description:
#   Checks of the remote environment:
#     - virtual machine id/name
#     - remote storage
#
# Usage:
#   CheckStorage
#
# Examples:
#   CheckStorage
#

function CheckStorage() {

  local _FUNCTION_ID="CheckStorage"
  local _STATE=0

  local _storage="$1"

  _msg_args+=(\
  "directory: '${_storage}'")

  _cmd_args+=(\
  "ssh ${ssh_opt} ${hv_host} -p ${port} if [[ ! -d \"${_storage}\" ]] ; then exit 1 ; fi")

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: GetRemote()
#
# Description:
#   Dump of the remote environment to local.
#
# Usage:
#   GetRemote
#
# Examples:
#   GetRemote
#

function GetRemote() {

  local _FUNCTION_ID="GetRemote"
  local _STATE=0

  local _file="$1"

  _msg_args+=(\
  "checking: '$_file'" \
  "get src: '$_file'")

  _cmd_args+=(\
  "ssh ${ssh_opt} ${hv_host} -p ${port} if [[ ! -e \"${_file}\" ]] ; then exit 1 ; fi" \
  "scp ${ssh_opt} -P ${port} ${hv_host}:${_file} ${_file}")

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: VmImport()
#
# Description:
#   Imports the virtual machine.
#
# Usage:
#   VmImport
#
# Examples:
#   VmImport
#

function VmImport() {

  local _FUNCTION_ID="VmImport"
  local _STATE=0

  local _x=1

  _sprintf "info" "set directory: '$lo_path'"

  cd "$lo_path" || \
  _logger "stop" \
    "${_FUNCTION_ID}()" \
    "directory change error: '$lo_path'"

  _fname=""
  for _fname in $(find ./* -type f -name "*.$pve_format" | cut -d "/" -f2 | sort -V) ; do

    _fda="$_fname"

    _msg_args+=(\
    "checking: '${_fda}'")

    _cmd_args+=(\
    "eval if [[ ! -e ${_fda} ]] ; then exit 1 ; fi")

    if [[ "$pve_format" == "img" ]] ; then

      local _vm_pv_local="${pve_lvm}/vm-${pve_id}-disk-${_x}"

      if [[ "$pve_host" == "local" ]] ; then

        _msg_args+=(\
        "checking: '${_vm_pv_local}'" \
        "src: '${_fda}', dst path: '${_vm_pv_local}'")

        _cmd_args+=(\
        "eval if [[ ! -e ${_vm_pv_local} ]] ; then exit 1 ; fi" \
        "dd if=${_fda} of=${_vm_pv_local} ${dd_opt}")

      elif [[ "$pve_host" != "local" ]] ; then

        _msg_args+=(\
        "checking: '${pve_host}:${_vm_pv_local}'" \
        "src: '${_fda}', dst path: '${pve_host}:${_vm_pv_local}'")

        _cmd_args+=(\
        "ssh ${ssh_opt} ${pve_host} -p ${port} if [[ ! -e \"${_vm_pv_local}\" ]] ; then exit 1 ; fi" \
        "eval dd if=${_fda} ${dd_opt} | ssh ${ssh_opt} ${pve_host} -p ${port} dd of=${_vm_pv_local} ${dd_opt}")

      fi

      if [[ "$remove_unused" == "yes" ]] ; then

        _msg_args+=(\
        "remove: '${_fda}'")

        _cmd_args+=(\
        "rm -fr ${_fda}")

      fi

    elif [[ "$pve_format" == "qcow2" ]] ; then

      local _vm_pv_local="${pv_path}/vm-${pve_id}-disk-${_x}.qcow2"

      if [[ "$pve_host" == "local" ]] ; then

        _msg_args+=(\
        "checking: '${_vm_pv_local}'" \
        "src: '${_fda}'")

        _cmd_args+=(\
        "eval if [[ ! -e ${_vm_pv_local} ]] ; then exit 1 ; fi" \
        "cp ${_fda} ${_vm_pv_local}")

      elif [[ "$pve_host" != "local" ]] ; then

        _msg_args+=(\
        "checking: '${pve_host}:${_vm_pv_local}'" \
        "src: '${_fda}'")

        _cmd_args+=(\
        "ssh ${ssh_opt} ${pve_host} -p ${port} if [[ ! -e \"${_vm_pv_local}\" ]] ; then exit 1 ; fi" \
        "scp ${ssh_opt} ${_fda} -P ${port} ${pve_host}:${_vm_pv_local}")

      fi

      if [[ "$remove_unused" == "yes" ]] ; then

        _msg_args+=(\
        "remove: '${_fda}'")

        _cmd_args+=(\
        "rm -fr ${_fda}")

      fi

    fi

    _x=$((_x + 1))

  done

  return $_STATE

}
