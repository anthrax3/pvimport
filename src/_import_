#!/usr/bin/env bash

################################################################################
######################## Definitions of user variables #########################
################################################################################


################################################################################
######################## Definitions of user functions #########################
################################################################################

# ``````````````````````````````````````````````````````````````````````````````
# Function name: InitEnv()
#
# Description:
#   Initialization of the environment for other functions.
#
# Usage:
#   InitEnv
#
# Examples:
#   InitEnv
#

function InitEnv() {

  local _FUNCTION_ID="InitEnv"
  local _STATE=0

  _sprintf "head" "creating and checking configuration of local environment"

  _logger "head" \
    "${_FUNCTION_ID}()" \
    "creating and checking configuration of local environment"

  # Display of variable values without checking them.
  for i in "hv_type" \
           "hv_host" \
           "vm_id" \
           "vm_name" \
           "pve_id" \
           "pve_format" \
           "hv_storage" \
           "local_storage" \
           "pve_storage" \
           "pve_lvm" \
           "pve_import" \
           "pve_host" \
           "re_path" \
           "lo_path" \
           "port" \
           "ssh_opt" \
           "dd_opt" ; do

    _i="" ; eval _i='$'$i

    local _num='^[0-9]+$'

    # shellcheck disable=SC2154
    # Checking variable values (if they are incorrect values).
    case $i in

      hv_type)

        if [[ "$hv_type" != "vmware" ]] && [[ "$hv_type" != "xen" ]] ; then

          _sprintf "stop" "hv_type: incorrectly set hypervisor type (properly: 'xen' or 'vmware')"

          _logger "stop" \
            "${_FUNCTION_ID}()" \
            "hv_type: incorrectly set hypervisor type (properly: 'xen' or 'vmware')"

        fi

      ;;

      pve_id)

        # We check the virtual machine ID and its numeric value.
        if [[ "$pve_id" =~ $_num ]] ; then

          # shellcheck disable=SC2143
          # If the value is a number then we check whether
          # the virtual machine with that identifier exists in the proxmox cluster.
          if [[ ! $(grep "qemu" /etc/pve/.vmlist | cut -d ":" -f1 | grep "$pve_id") ]] ; then

            _sprintf "stop" "pve_id: vm with this id does not exist"

            _logger "stop" \
              "${_FUNCTION_ID}()" \
              "pve_id: vm with this id does not exist"

          fi

        else

          _sprintf "stop" "pve_id: vm id has no numeric value"

          _logger "stop" \
            "${_FUNCTION_ID}()" \
            "pve_id: vm id has no numeric value"

        fi

      ;;

      pve_format)

        if [[ "$pve_format" != "img" ]] && [[ "$pve_format" != "qcow2" ]] ; then

          _sprintf "stop" "pve_format: incorrectly set format type (properly: 'img' or 'qcow2')"

          _logger "stop" \
            "${_FUNCTION_ID}()" \
            "pve_format: incorrectly set format type (properly: img or qcow2)"

        fi

      ;;

      pv_import)

        # We start the import when calling the --import option.
        if [[ "$pve_import" != "true" ]] ; then

          pve_import="false"
          pve_host="local"

        fi

      ;;

      lo_path)

        if [[ ! -d "$lo_path" ]] ; then

          _sprintf "info" "lo_path: creating a local directory: '$lo_path'"

          _logger "info" \
            "${_FUNCTION_ID}()" \
            "lo_path: creating a local directory: '$lo_path'"

          mkdir -p "$lo_path"

        fi

      ;;

      pve_storage)

        if [[ ! -d "$pve_storage" ]] ; then

          _sprintf "stop" "pve_storage: incorrectly set storage (does not exist?)"

          _logger "stop" \
            "${_FUNCTION_ID}()" \
            "pve_storage: incorrectly set storage (does not exist?)"

        fi

      ;;

      pve_lvm)

        if [[ ! -e "$pve_lvm" ]] ; then

          _sprintf "stop" "pve_lvm: incorrectly set lvm (does not exist?)"

          _logger "stop" \
            "${_FUNCTION_ID}()" \
            "pve_lvm: incorrectly set lvm (does not exist?)"

        fi

      ;;

    esac

    _sprintf "info" "${i}: '$_i'"

    _logger "info" \
      "${_FUNCTION_ID}()" \
      "${i}: '$_i'"

  done

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: InitFunction()
#
# Description:
#   It deals with launching functions:
#     - creates a simple environment for the functions you perform
#     - operates on message to display and command to execute
#
# Usage:
#   InitFunction function_name params
#
# Examples:
#   InitFunction "CheckConn 172.20.20.50 22"
#

function InitFunction() {

  local _FUNCTION_ID="InitFunction"
  local _STATE=0

  local _args=("$@")

  _logger "info" \
    "${_FUNCTION_ID}()" \
    "init function: '${_args[@]}'"

  # In these two variables we store the message to display
  # and the command to execute.
  export _msg_args=()
  export _cmd_args=()

  eval "${_args[@]}" ; if [ ! $? ] ; then _exit_ 255 ; fi

  _num=${#_msg_args[@]}
  for (( _xa=0 ; _xa<=((_num - 1)) ; _xa++ )) ; do

    _msg="${_msg_args[$_xa]}"
    _full_command="${_cmd_args[$_xa]}"

    _sprintf "info" "$_msg"

    _logger "info" \
      "${_FUNCTION_ID}()" \
      "$_msg"

    _init_cmd "$_full_command" ; if [ ! $? ] ; then _exit_ 255 ; fi

  done

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: CheckConn()
#
# Description:
#   Validates the connection to the remote server.
#
# Usage:
#   CheckConn host port
#
# Examples:
#   CheckConn 172.20.20.50 22
#

function CheckConn() {

  local _FUNCTION_ID="CheckConn"
  local _STATE=0

  local _host="$1"
  local _port="$2"

  # We test two types of connections that will be used.
  _msg_args+=(\
  "host (tcp): '${_host}'" \
  "host (ssh): '${_host}'")

  _cmd_args+=(\
  "eval timeout 1 bash -c \"</dev/tcp/${_host}/${_port}\"" \
  "ssh ${ssh_opt} ${_host} -p ${_port} exit 0")

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: FlushRemoteFiles()
#
# Description:
#   Flush remote config files.
#
# Usage:
#   FlushRemoteFiles /path/to/file
#
# Examples:
#   FlushRemoteFiles /tmp/.cache
#

function FlushRemoteFiles() {

  local _FUNCTION_ID="FlushRemoteFiles"
  local _STATE=0

  local _file="$1"

  _msg_args+=(\
  "src: '${_file}")

  _cmd_args+=(\
  "ssh ${ssh_opt} ${hv_host} -p ${port} >${_file}")

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: CheckRemoteStorage()
#
# Description:
#   Checks of the remote environment:
#     - remote storage
#
# Usage:
#   CheckRemoteStorage /path/to/directory
#
# Examples:
#   CheckRemoteStorage /var/log
#

function CheckRemoteStorage() {

  local _FUNCTION_ID="CheckRemoteStorage"
  local _STATE=0

  local _storage="$1"

  _msg_args+=(\
  "directory: '${_storage}'")

  _cmd_args+=(\
  "ssh ${ssh_opt} ${hv_host} -p ${port} if [[ ! -d \"${_storage}\" ]] ; then exit 1 ; fi")

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: GetRemoteFiles()
#
# Description:
#   Dump of the remote environment to local.
#
# Usage:
#   GetRemoteFiles /path/to/file
#
# Examples:
#   GetRemoteFiles /tmp/.cache
#

function GetRemoteFiles() {

  local _FUNCTION_ID="GetRemoteFiles"
  local _STATE=0

  local _file="$1"

  _msg_args+=(\
  "checking: '$_file'" \
  "get src: '$_file'")

  _cmd_args+=(\
  "ssh ${ssh_opt} ${hv_host} -p ${port} if [[ ! -e \"${_file}\" ]] ; then exit 1 ; fi" \
  "scp ${ssh_opt} -P ${port} ${hv_host}:${_file} ${_file}")

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: VmImport()
#
# Description:
#   Imports the virtual machine disks to any Proxmox node.
#
# Usage:
#   VmImport /path/to/local/disk
#
# Examples:
#   VmImport /xfs900/datastore/vmware/PROD-web01.img
#

function VmImport() {

  local _FUNCTION_ID="VmImport"
  local _STATE=0

  local _fda="$1"
  local _x=1

  _msg_args+=(\
  "checking: '${_fda}'")

  _cmd_args+=(\
  "eval if [[ ! -e ${_fda} ]] ; then exit 1 ; fi")

  if [[ "$pve_format" == "img" ]] ; then

    local _vm_pv_local="${pve_lvm}/vm-${pve_id}-disk-${_x}"

    if [[ "$pve_host" == "local" ]] ; then

      _msg_args+=(\
      "checking: '${_vm_pv_local}'" \
      "src: '${_fda}', dst path: '${_vm_pv_local}'")

      _cmd_args+=(\
      "eval if [[ ! -e ${_vm_pv_local} ]] ; then exit 1 ; fi" \
      "dd if=${_fda} of=${_vm_pv_local} ${dd_opt}")

    elif [[ "$pve_host" != "local" ]] ; then

      _msg_args+=(\
      "checking: '${pve_host}:${_vm_pv_local}'" \
      "src: '${_fda}', dst path: '${pve_host}:${_vm_pv_local}'")

      _cmd_args+=(\
      "ssh ${ssh_opt} ${pve_host} -p ${port} if [[ ! -e \"${_vm_pv_local}\" ]] ; then exit 1 ; fi" \
      "eval dd if=${_fda} ${dd_opt} | ssh ${ssh_opt} ${pve_host} -p ${port} dd of=${_vm_pv_local} ${dd_opt}")

    fi

    if [[ "$remove_unused" == "yes" ]] ; then

      _msg_args+=(\
      "remove: '${_fda}'")

      _cmd_args+=(\
      "rm -fr ${_fda}")

    fi

  elif [[ "$pve_format" == "qcow2" ]] ; then

    local _vm_pv_local="${pv_path}/vm-${pve_id}-disk-${_x}.qcow2"

    if [[ "$pve_host" == "local" ]] ; then

      _msg_args+=(\
      "checking: '${_vm_pv_local}'" \
      "src: '${_fda}'")

      _cmd_args+=(\
      "eval if [[ ! -e ${_vm_pv_local} ]] ; then exit 1 ; fi" \
      "cp ${_fda} ${_vm_pv_local}")

    elif [[ "$pve_host" != "local" ]] ; then

      _msg_args+=(\
      "checking: '${pve_host}:${_vm_pv_local}'" \
      "src: '${_fda}'")

      _cmd_args+=(\
      "ssh ${ssh_opt} ${pve_host} -p ${port} if [[ ! -e \"${_vm_pv_local}\" ]] ; then exit 1 ; fi" \
      "scp ${ssh_opt} ${_fda} -P ${port} ${pve_host}:${_vm_pv_local}")

    fi

    if [[ "$remove_unused" == "yes" ]] ; then

      _msg_args+=(\
      "remove: '${_fda}'")

      _cmd_args+=(\
      "rm -fr ${_fda}")

    fi

  fi

  _x=$((_x + 1))

  return $_STATE

}
