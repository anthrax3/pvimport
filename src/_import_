# shellcheck shell=bash

################################################################################
######################## Definitions of user variables #########################
################################################################################


################################################################################
######################## Definitions of user functions #########################
################################################################################

# ``````````````````````````````````````````````````````````````````````````````
# Function name: InitEnv()
#
# Description:
#   Initialization of the environment for other functions.
#
# Usage:
#   InitEnv "param_0" "param_1"
#
# Examples:
#   InitEnv conn_params[@] hypervisor_params[@]
#

function InitEnv() {

  local _FUNCTION_ID="InitEnv"
  local _STATE=0

  local conn_params=("${!1}")
  local hypervisor_params=("${!2}")

  # Hypervisor variables.
  local pv_host="${conn_params[0]}"
  local pv_port="${conn_params[1]}"

  local pv_type="${hypervisor_params[0]}"
  local pv_storage="${hypervisor_params[1]}"
  local pv_id="${hypervisor_params[2]}"
  local pv_name="${hypervisor_params[3]}"

  # Local machine variables.
  local pv_lstorage="${hypervisor_params[4]}"

  # Proxmox variables.
  local pv_storage_pve="${hypervisor_params[5]}"
  local pv_lvm_pve="${hypervisor_params[6]}"
  local pv_id_pve="${hypervisor_params[7]}"
  local pv_format_pve="${hypervisor_params[8]}"
  local pv_import_pve="${hypervisor_params[9]}"
  local pv_host_pve="${hypervisor_params[10]}"

  # Full paths to the appropriate resources (based on what is above).
  local re_path="${pv_storage}/${pv_name}"
  local lo_path="${pv_lstorage}/${pv_host}/${pv_name}"
  local pvpath="${pv_storage_pve}/${pv_id_pve}"

  # Functions stack description:
  #   CheckConn       - check the connection to the server (xen/vmware)
  #   InitRemoteEnv   - creates a remote environment (xen/vmware)
  #   CheckRemoteEnv  - checks a remote environment (xen/vmware)
  #   VmExport        - export Virtual Machine (xen)
  #   VmCopy          - copy Virtual Machine (xen/vmware)
  #   VmExtract       - extract Virtual Machine disks (xen)
  #   VmConvertDisks  - convert Virtual Machine (xen/vmware)
  #   VmImport        - import Virtual Machine (xen/vmware)

  if [[ "$pv_type" == "xen" ]] ; then

    local _function_stack=(CheckConn InitRemoteEnv CheckRemoteEnv \
                           VmExport VmCopy VmExtract VmConvertDisks)

  elif [[ "$pv_type" == "vmware" ]] ; then

    local _function_stack=(CheckConn InitRemoteEnv CheckRemoteEnv \
                           DumpRemoteEnv VmCopy VmConvertDisks)

  else

    _sprintf "stop" "incorrectly set hypervisor type (properly: xen or vmware)"

    _logger "stop" \
      "${_FUNCTION_ID}()" \
      "incorrectly set hypervisor type (properly: xen or vmware)"

  fi

  # We start the import when calling the --import option.
  if [[ "$pv_import_pve" == "true" ]] ; then

    _function_stack+=(VmImport)

  else

    pv_import_pve="false"
    pv_host_pve="local"

  fi

  _sprintf "head" "creating and checking local environment"

  _logger "head" \
    "${_FUNCTION_ID}()" \
    "creating and checking local environment"

  # Display of variable values without checking them.
  for i in "pv_host" \
           "pv_port" \
           "ssh_opt" \
           "pv_type" \
           "pv_id" \
           "pv_name" \
           "re_path" \
           "lo_path" \
           "pv_storage_pve" \
           "pv_lvm_pve" \
           "pv_id_pve" \
           "pv_format_pve" \
           "pv_import_pve" \
           "pv_host_pve" ; do

    _i="" ; eval _i='$'$i

    _sprintf "info" "${i}: '$_i'"

    _logger "info" \
      "${_FUNCTION_ID}()" \
      "${i}: '$_i'"

    # First, we check the virtual machine ID and its numeric value.
    local _num='^[0-9]+$'

    if [[ "$i" == "pv_id_pve" ]] ; then

      if [[ "$pv_id_pve" =~ $_num ]] ; then

        # shellcheck disable=SC2143
        # If the value is a number then we check whether
        # the virtual machine with that identifier exists in the proxmox cluster.
        if [[ ! $(grep "qemu" /etc/pve/.vmlist | cut -d ":" -f1 | grep "$pv_id_pve") ]] ; then

          _sprintf "stop" "vm with this id does not exist"

          _logger "stop" \
            "${_FUNCTION_ID}()" \
            "vm with this id does not exist"

        fi

      else

        _sprintf "stop" "vm id has no numeric value"

        _logger "stop" \
          "${_FUNCTION_ID}()" \
          "vm id has no numeric value"

      fi

    fi

    # Checking variable values (if they are incorrect values).
    if [[ ! -d "$pv_storage_pve" ]] || \
       [[ ! -e "$pv_lvm_pve" ]] || \
       [[ "$pv_format_pve" != "img" ]] && [[ "$pv_format_pve" != "qcow2" ]] ; then

      _sprintf "stop" "value: incorrect"

      _logger "stop" \
        "${_FUNCTION_ID}()" \
        "value: incorrect"

    fi

  done

  if [[ ! -d "$lo_path" ]] ; then

    _sprintf "info" "creating a local directory: '$lo_path'"

    _logger "info" \
      "${_FUNCTION_ID}()" \
      "creating a local directory: '$lo_path'"

    mkdir -p "$lo_path"

  fi

  # Launch all functions.
  InitPv

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: InitPv()
#
# Description:
#   Validates the connection to the remote server.
#
# Usage:
#   InitPv
#
# Examples:
#   InitPv
#

function InitPv() {

  local _FUNCTION_ID="InitPv"
  local _STATE=0

  for _function in "${_function_stack[@]}" ; do

    _logger "info" \
      "${_FUNCTION_ID}()" \
      "init function: $_function"

    export _msg_args=()
    export _cmd_args=()

    $_function ; if [ ! $? ] ; then _exit_ 255 ; fi

    _num=${#_msg_args[@]}
    for (( _xa=0 ; _xa<=((_num - 1)) ; _xa++ )) ; do

      _msg="${_msg_args[$_xa]}"
      _full_command="${_cmd_args[$_xa]}"

      _sprintf "info" "$_msg"

      _logger "info" \
        "${_FUNCTION_ID}()" \
        "$_msg"

      _init_cmd "$_full_command" ; if [ ! $? ] ; then _exit_ 255 ; fi

    done

  done

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: CheckConn()
#
# Description:
#   Validates the connection to the remote server.
#
# Usage:
#   CheckConn
#
# Examples:
#   CheckConn
#

function CheckConn() {

  local _FUNCTION_ID="CheckConn"
  local _STATE=0

  _sprintf "head" "checking connection to remote host(s)"

  _logger "head" \
    "${_FUNCTION_ID}()" \
    "checking connection to remote host(s)"

  _msg_args+=(\
  "host: '${pv_host}'")

  _cmd_args+=(\
  "eval timeout 1 bash -c \"</dev/tcp/${pv_host}/${pv_port}\"")

  if [[ "$pv_host_pve" != "local" ]] ; then

    _msg_args+=(\
    "host: '${pv_host_pve}'")

    _cmd_args+=(\
    "eval timeout 1 bash -c \"</dev/tcp/${pv_host_pve}/${pv_port}\"")

  fi

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: InitRemoteEnv()
#
# Description:
#   Initialization of the remote environment.
#
# Usage:
#   InitRemoteEnv
#
# Examples:
#   InitRemoteEnv
#

function InitRemoteEnv() {

  local _FUNCTION_ID="InitRemoteEnv"
  local _STATE=0

  _sprintf "head" "preparing remote environment"

  _logger "head" \
    "${_FUNCTION_ID}()" \
    "preparing remote environment"

  _msg_args+=(\
  "resetting '${_pv_xen_vars}'" \
  "resetting '${_pv_vmware_vars}'" \
  "resetting '${_pv_vmware_disks}")

  _cmd_args+=(\
  "ssh ${ssh_opt} ${pv_host} -p ${pv_port} >${_pv_xen_vars}" \
  "ssh ${ssh_opt} ${pv_host} -p ${pv_port} >${_pv_vmware_vars}" \
  "ssh ${ssh_opt} ${pv_host} -p ${pv_port} >${_pv_vmware_disks}")

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: CheckRemoteEnv()
#
# Description:
#   Checks of the remote environment.
#
# Usage:
#   CheckRemoteEnv
#
# Examples:
#   CheckRemoteEnv
#

function CheckRemoteEnv() {

  local _FUNCTION_ID="CheckRemoteEnv"
  local _STATE=0

  _sprintf "head" "checking remote environment"

  _logger "head" \
    "${_FUNCTION_ID}()" \
    "checking remote environment"

  if [[ "$pv_type" == "xen" ]] ; then

    _msg_args+=(\
    "vm id: '${pv_id}'" \
    "directory: '${pv_storage}'")

    _cmd_args+=(\
    "ssh ${ssh_opt} ${pv_host} -p ${pv_port} if [[ ! \$(xe vm-list | grep ${pv_id}) ]] ; then exit 1 ; fi" \
    "ssh ${ssh_opt} ${pv_host} -p ${pv_port} if [[ ! -d \"${pv_storage}\" ]] ; then exit 1 ; fi")

  elif [[ "$pv_type" == "vmware" ]] ; then

    _msg_args+=(\
    "vm id: '${pv_id}'" \
    "vm directory: '${re_path}'")

    _cmd_args+=(\
    "ssh ${ssh_opt} ${pv_host} -p ${pv_port} if [[ ! \$(vim-cmd vmsvc/getallvms | grep ${pv_id}) ]] ; then exit 1 ; fi" \
    "ssh ${ssh_opt} ${pv_host} -p ${pv_port} if [[ ! -d \"${re_path}\" ]] ; then exit 1 ; fi")

  fi

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: DumpRemoteEnv()
#
# Description:
#   Dump of the remote environment to local.
#
# Usage:
#   DumpRemoteEnv
#
# Examples:
#   DumpRemoteEnv
#

function DumpRemoteEnv() {

  local _FUNCTION_ID="DumpRemoteEnv"
  local _STATE=0

  _sprintf "head" "dump remote environment"

  _logger "head" \
    "${_FUNCTION_ID}()" \
    "dump remote environment"

  if [[ "$pv_type" == "vmware" ]] ; then

    _msg_args+=(\
    "dump vm config file" \
    "dump vm disks list" \
    "get vm config list" \
    "get vm disks list")

    _cmd_args+=(\
    "ssh ${ssh_opt} ${pv_host} -p ${pv_port} find \"${re_path}\" -name \"*.vmx\" -printf \"%P\n\" >> ${_pv_vmware_vars}" \
    "ssh ${ssh_opt} ${pv_host} -p ${pv_port} find \"${re_path}\" -name \"*.vmdk\" -printf \"%P\n\" >> ${_pv_vmware_disks}" \
    "scp ${ssh_opt} -P ${pv_port} ${pv_host}:${re_path}/${_pv_vmware_vars} ${_pv_vmware_vars}" \
    "scp ${ssh_opt} -P ${pv_port} ${pv_host}:${re_path}/${_pv_vmware_disks} ${_pv_vmware_disks}")

  fi

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: VmExport()
#
# Description:
#   Exports the virtual machine.
#
# Usage:
#   VmExport
#
# Examples:
#   VmExport
#

function VmExport() {

  local _FUNCTION_ID="VmExport"
  local _STATE=0

  _sprintf "head" "exporting $pv_id"

  _logger "info" \
    "${_FUNCTION_ID}()" \
    "exporting $pv_id"

  _msg_args+=(\
  "creating snapshot: '${pv_name}-${_random}'" \
  "exporting snapshot: '${pv_name}.ova'")

  _cmd_args+=(\
  "ssh ${ssh_opt} ${pv_host} -p ${pv_port} _id=\$(xe vm-snapshot vm=${pv_id} new-name-label=${pv_name}-${_random}) ; echo \$_id >> ${_pv_xen_vars}" \
  "ssh ${ssh_opt} ${pv_host} -p ${pv_port} _id=\$(cat ${_pv_xen_vars}) ; xe vm-export vm=\${_id} filename=${pv_storage}/${pv_name}.ova")

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: VmCopy()
#
# Description:
#   Copies the virtual machine from remote host to local (target) host.
#
# Usage:
#   VmCopy
#
# Examples:
#   VmCopy
#

function VmCopy() {

  local _FUNCTION_ID="VmCopy"
  local _STATE=0

  _sprintf "head" "copying a virtual machine disks"

  _logger "info" \
    "${_FUNCTION_ID}()" \
    "copying a virtual machine disks"

  local _vmx_name
  local _vmdk_name

  if [[ "$pv_type" == "xen" ]] ; then

    _msg_args+=(\
    "checking: '${pv_name}.ova'" \
    "src: '${pv_name}.ova', dst path: '${lo_path}'")

    _cmd_args+=(\
    "ssh ${ssh_opt} ${pv_host} -p ${pv_port} if [[ ! -e \"${pv_storage}/${pv_name}.ova\" ]] ; then exit 1 ; fi" \
    "scp ${ssh_opt} -P ${pv_port} ${pv_host}:${pv_storage}/${pv_name}.ova ${lo_path}")

  elif [[ "$pv_type" == "vmware" ]] ; then

    _vmx_name=$(grep ".vmx" "$_pv_vmware_vars")
    _vmdk_name=$(grep ".vmdk" "$_pv_vmware_disks")

    _msg_args+=(\
    "checking: '${_vmx_name}'" \
    "config file: '${_vmx_name}', dst path: '${lo_path}'")

    _cmd_args+=(\
    "ssh ${ssh_opt} ${pv_host} -p ${pv_port} if [[ ! -e \"${re_path}/${_vmx_name}\" ]] ; then exit 1 ; fi" \
    "scp ${ssh_opt} -P ${pv_port} ${pv_host}:${re_path}/${_vmx_name} ${lo_path}")

    # Issue to solve:
    # shellcheck disable=SC2013
    for _fname in $(cat "$_vmdk_name") ; do

      _msg_args+=(\
      "checking: '${_fname}'" \
      "src: '${_fname}', dst path: '${lo_path}'")

      _cmd_args+=(\
      "ssh ${ssh_opt} ${pv_host} -p ${pv_port} if [[ ! -e \"${re_path}/${_fname}\" ]] ; then exit 1 ; fi" \
      "scp ${ssh_opt} -P ${pv_port} ${pv_host}:${re_path}/${_fname} ${lo_path}")

    done

  fi

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: VmExtract()
#
# Description:
#   Extracts the virtual machine disks.
#
# Usage:
#   VmExtract
#
# Examples:
#   VmExtract
#

function VmExtract() {

  local _FUNCTION_ID="VmExtract"
  local _STATE=0

  _sprintf "head" "extracting ova files"

  _logger "info" \
    "${_FUNCTION_ID}()" \
    "extracting ova files"

  _msg_args+=(\
  "src: '${pv_name}.ova', dst path: '${lo_path}'")

  _cmd_args+=(\
  "tar xf ${lo_path}/${pv_name}.ova -C ${lo_path}")

  # shellcheck disable=SC2154
  if [[ "$remove_unused" == "yes" ]] ; then

    # We're checking to make sure there is.
    if [[ -e "${lo_path}/${pv_name}.ova" ]] ; then
    
      _msg_args+=(\
      "remove: '${pv_name}.ova'")

      _cmd_args+=(\
      "rm -fr ${lo_path}/${pv_name}.ova")

    fi

  fi

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: VmConvertDisks()
#
# Description:
#   Converts the virtual machine disks.
#
# Usage:
#   VmConvertDisks
#
# Examples:
#   VmConvertDisks
#

function VmConvertDisks() {

  local _FUNCTION_ID="VmConvertDisks"
  local _STATE=0

  _sprintf "head" "converting disks to $pv_format_pve format"

  _logger "info" \
    "${_FUNCTION_ID}()" \
    "converting disks to $pv_format_pve format"

  local _vmx_file
  local _x

  _sprintf "info" "set directory: $lo_path"

  cd "$lo_path" || \
  _logger "stop" \
    "${_FUNCTION_ID}()" \
    "directory change error: $lo_path"

  if [[ "$pv_type" == "xen" ]] ; then

    _x=1

    # Issue to solve:
    # shellcheck disable=SC2044
    for _fda in $(find . -type d -name "Ref:*" -printf '%P\n') ; do

      _name=$(echo "$_fda" | tr ":" "_")

      _msg_args+=(\
      "src: '${_fda}', dst: '${_x}-${_name}.img'")

      _cmd_args+=(\
      "xenmigrate --convert=${_fda} ${_x}-${_name}.img")

      if [[ "$pv_format_pve" == "qcow2" ]] ; then

        _fdb="${_name}.img"
        _nname="${_fdb%.*}"

        _msg_args+=(\
        "src: '${_fdb}', dst: '${_x}-${_nname}.qcow2'")

        _cmd_args+=(\
        "qemu-img convert -f raw -O qcow2 ${_fdb} ${_x}-${_nname}.qcow2")

      fi

      if [[ "$remove_unused" == "yes" ]] ; then

        # We're checking to make sure there is.
        if [[ -e "$_fda" ]] ; then
    
          _msg_args+=(\
          "remove: '${_fda}'")

          _cmd_args+=(\
          "rm -fr ${_fda}")

          if [[ -e "$_fdb" ]] ; then

            _msg_args+=(\
            "remove: '${_fdb}'")

            _cmd_args+=(\
            "rm -fr ${_fdb}")

          fi

        fi

      fi

    _x=$((_x + 1))

    done

  elif [[ "$pv_type" == "vmware" ]] ; then

    _vmx_file=$(find . -name "*.vmx")
    _x=1

    # Issue to solve:
    # shellcheck disable=SC2013
    for _fda in $(grep ".vmdk" "$_vmx_file" | cut -d "\"" -f2) ; do

      if [[ "$_fda" != *"flat"* ]] ; then

        _name="${_fda%.*}"

        if [[ "$pv_format_pve" == "qcow2" ]] ; then

          _msg_args+=(\
          "src: '${_fda}', dst: '${_x}-${_name}.qcow2'")

          _cmd_args+=(\
          "qemu-img convert -f vmdk -O qcow2 ${_fda} ${_x}-${_name}.qcow2")

        elif [[ "$pv_format_pve" == "img" ]] ; then

          _msg_args+=(\
          "src: '${_fda}', dst: '${_x}-${_name}.img'")

          _cmd_args+=(\
          "qemu-img convert -f vmdk -O raw ${_fda} ${_x}-${_name}.img")

        fi

        if [[ "$remove_unused" == "yes" ]] ; then

          # We're checking to make sure there is.
          if [[ -e "$_fda" ]] ; then
    
            _msg_args+=(\
            "remove: '${_fda}'")

            _cmd_args+=(\
            "rm -fr ${_fda}")

            if [[ -e "${_name}-flat.vmdk" ]] ; then

              _msg_args+=(\
              "remove: '${_name}-flat.vmdk")

              _cmd_args+=(\
              "rm -fr ${_name}-flat.vmdk")

            fi

          fi

        fi

      fi

      _x=$((_x + 1))

    done

  fi

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: VmImport()
#
# Description:
#   Imports the virtual machine.
#
# Usage:
#   VmImport
#
# Examples:
#   VmImport
#

function VmImport() {

  local _FUNCTION_ID="VmImport"
  local _STATE=0

  _sprintf "head" "importing a virtual machine disks"

  _logger "info" \
    "${_FUNCTION_ID}()" \
    "importing a virtual machine disks"

  local _x=1

  _sprintf "info" "set directory: $lo_path"

  cd "$lo_path" || \
  _logger "stop" \
    "${_FUNCTION_ID}()" \
    "directory change error: $lo_path"

  for _fda in $(find . -type f -name "*.$pv_format_pve" -printf '%P\n' | sort -V) ; do
  
    if [[ "$pv_format_pve" == "img" ]] ; then

      local _vm_pv_local="${pv_lvm_pve}/vm-${pv_id_pve}-disk-${_x}"

      if [[ "$pv_host_pve" == "local" ]] ; then

        _msg_args+=(\
        "checking: '${_vm_pv_local}'" \
        "src: '${_fda}', dst path: '${_vm_pv_local}'")

        _cmd_args+=(\
        "eval if [[ ! -e ${_vm_pv_local} ]] ; then exit 1 ; fi" \
        "dd if=${_fda} of=${_vm_pv_local}")

      elif [[ "$pv_host_pve" != "local" ]] ; then

        _msg_args+=(\
        "checking: '${pv_host_pve}:${_vm_pv_local}'" \
        "src: '${_fda}', dst path: '${pv_host_pve}:${_vm_pv_local}'")

        _cmd_args+=(\
        "ssh ${ssh_opt} ${pv_host_pve} -p ${pv_port} if [[ ! -e \"${_vm_pv_local}\" ]] ; then exit 1 ; fi" \
        "eval dd if=${_fda} bs=4096 | ssh ${ssh_opt} ${pv_host_pve} -p ${pv_port} dd of=${_vm_pv_local} bs=4096")

      fi

      if [[ "$remove_unused" == "yes" ]] ; then

        # We're checking to make sure there is.
        if [[ -e "$_fda" ]] ; then
    
          _msg_args+=(\
          "remove: '${_fda}'")

          _cmd_args+=(\
          "rm -fr ${_fda}")

        fi

      fi

    elif [[ "$pv_format_pve" == "qcow2" ]] ; then

      local _vm_pv_local="${pvpath}/vm-${pv_id_pve}-disk-${_x}.qcow2"

      if [[ "$pv_host_pve" == "local" ]] ; then

        _msg_args+=(\
        "checking: '${_vm_pv_local}'" \
        "src: '${_fda}', dst path: '${_vm_pv_local}'")

        _cmd_args+=(\
        "eval if [[ ! -e ${_vm_pv_local} ]] ; then exit 1 ; fi" \
        "cp ${_fda} ${_vm_pv_local}")

      elif [[ "$pv_host_pve" != "local" ]] ; then

        _msg_args+=(\
        "checking: '${pv_host_pve}:${_vm_pv_local}'" \
        "src: '${_fda}', dst path: '${pv_host_pve}:${_vm_pv_local}'")

        _cmd_args+=(\
        "ssh ${ssh_opt} ${pv_host_pve} -p ${pv_port} if [[ ! -e \"${_vm_pv_local}\" ]] ; then exit 1 ; fi" \
        "scp ${ssh_opt} ${_fda} -P ${pv_port} ${pv_host_pve}:${_vm_pv_local}")

      fi

      if [[ "$remove_unused" == "yes" ]] ; then

        # We're checking to make sure there is.
        if [[ -e "$_fda" ]] ; then
    
          _msg_args+=(\
          "remove: '${_fda}'")

          _cmd_args+=(\
          "rm -fr ${_fda}")

        fi

      fi

    fi

    _x=$((_x + 1))

  done

  return $_STATE

}
