# shellcheck shell=bash

################################################################################
######################## Definitions of user variables #########################
################################################################################


################################################################################
######################## Definitions of user functions #########################
################################################################################

# ``````````````````````````````````````````````````````````````````````````````
# Function name: InitEnv()
#
# Description:
#   Initialization of the environment for other functions.
#
# Usage:
#   InitEnv
#
# Examples:
#   InitEnv
#

function InitEnv() {

  local _FUNCTION_ID="InitEnv"
  local _STATE=0

  # Functions stack description:
  #   CheckConn       - check the connection to the server (xen/vmware)
  #   InitRemoteEnv   - creates a remote environment (xen/vmware)
  #   CheckRemoteEnv  - checks a remote environment (xen/vmware)
  #   VmExport        - export Virtual Machine (xen)
  #   VmCopy          - copy Virtual Machine (xen/vmware)
  #   VmExtract       - extract Virtual Machine disks (xen)
  #   VmConvertDisks  - convert Virtual Machine (xen/vmware)
  #   VmImport        - import Virtual Machine (xen/vmware)

  # shellcheck disable=SC2154
  if [[ "$hv_type" == "xen" ]] ; then

    _function_stack=("CheckConn $_hv_host $_hv_port" \
                     "CheckConn $pve_host $_hv_port" \
                     InitRemoteEnv CheckRemoteEnv \
                     VmExport VmCopy VmExtract VmConvertDisks)

  elif [[ "$hv_type" == "vmware" ]] ; then

    _function_stack=("CheckConn $_hv_host $_hv_port" \
                     "CheckConn $pve_host $_hv_port" \
                     InitRemoteEnv CheckRemoteEnv \
                     GetRemoteEnv VmCopy VmConvertDisks)

  else

    _sprintf "stop" "incorrectly set hypervisor type (properly: xen or vmware)"

    _logger "stop" \
      "${_FUNCTION_ID}()" \
      "incorrectly set hypervisor type (properly: xen or vmware)"

  fi

  # We start the import when calling the --import option.
  if [[ "$pve_import" == "true" ]] ; then

    _function_stack+=(VmImport)

  else

    pve_import="false"
    pve_host="local"

  fi

  _sprintf "head" "creating and checking configuration of local environment"

  _logger "head" \
    "${_FUNCTION_ID}()" \
    "creating and checking configuration of local environment"

  # Display of variable values without checking them.
  for i in "hv_host" \
           "hv_port" \
           "ssh_opt" \
           "hv_type" \
           "vm_id" \
           "vm_name" \
           "re_path" \
           "lo_path" \
           "pve_storage" \
           "pve_lvm" \
           "pve_id" \
           "pve_format" \
           "pve_import" \
           "pve_host" \
           "dd_opt" ; do

    _i="" ; eval _i='$'$i

    _sprintf "info" "${i}: '$_i'"

    _logger "info" \
      "${_FUNCTION_ID}()" \
      "${i}: '$_i'"

    # First, we check the virtual machine ID and its numeric value.
    local _num='^[0-9]+$'

    if [[ "$i" == "pve_id" ]] ; then

      if [[ "$pve_id" =~ $_num ]] ; then

        # shellcheck disable=SC2143
        # If the value is a number then we check whether
        # the virtual machine with that identifier exists in the proxmox cluster.
        if [[ ! $(grep "qemu" /etc/pve/.vmlist | cut -d ":" -f1 | grep "$pve_id") ]] ; then

          _sprintf "stop" "vm with this id does not exist"

          _logger "stop" \
            "${_FUNCTION_ID}()" \
            "vm with this id does not exist"

        fi

      else

        _sprintf "stop" "vm id has no numeric value"

        _logger "stop" \
          "${_FUNCTION_ID}()" \
          "vm id has no numeric value"

      fi

    fi

    # shellcheck disable=SC2154
    # Checking variable values (if they are incorrect values).
    if [[ ! -d "$pve_storage" ]] || \
       [[ ! -e "$pve_lvm" ]] || \
       [[ "$pve_format" != "img" ]] && [[ "$pve_format" != "qcow2" ]] ; then

      _sprintf "stop" "value: incorrect"

      _logger "stop" \
        "${_FUNCTION_ID}()" \
        "value: incorrect"

    fi

  done

  if [[ ! -d "$lo_path" ]] ; then

    _sprintf "info" "creating a local directory: '$lo_path'"

    _logger "info" \
      "${_FUNCTION_ID}()" \
      "creating a local directory: '$lo_path'"

    mkdir -p "$lo_path"

  fi

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: InitPv()
#
# Description:
#   Validates the connection to the remote server.
#
# Usage:
#   InitPv
#
# Examples:
#   InitPv
#

function InitPv() {

  local _FUNCTION_ID="InitPv"
  local _STATE=0

  IFS="$IFS_HACK"

  for _function in "${_function_stack[@]}" ; do

    _logger "info" \
      "${_FUNCTION_ID}()" \
      "init function: '$_function'"

    # In these two variables we store the message to display
    # and the command to execute.
    export _msg_args=()
    export _cmd_args=()

    $_function ; if [ ! $? ] ; then _exit_ 255 ; fi

    _num=${#_msg_args[@]}
    for (( _xa=0 ; _xa<=((_num - 1)) ; _xa++ )) ; do

      _msg="${_msg_args[$_xa]}"
      _full_command="${_cmd_args[$_xa]}"

      _sprintf "info" "$_msg"

      _logger "info" \
        "${_FUNCTION_ID}()" \
        "$_msg"

      _init_cmd "$_full_command" ; if [ ! $? ] ; then _exit_ 255 ; fi

    done

  done

  IFS="$IFS_ORIG"

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: CheckConn()
#
# Description:
#   Validates the connection to the remote server.
#
# Usage:
#   CheckConn
#
# Examples:
#   CheckConn
#

function CheckConn() {

  local _FUNCTION_ID="CheckConn"
  local _STATE=0

  local _host="$1"
  local _port="$2"

  _sprintf "head" "checking connection to remote host(s)"

  _logger "head" \
    "${_FUNCTION_ID}()" \
    "checking connection to remote host(s)"

  # We test two types of connections that will be used.
  _msg_args+=(\
  "host (tcp): '${_host}'" \
  "host (ssh): '${_port}'")

  _cmd_args+=(\
  "eval timeout 1 bash -c \"</dev/tcp/${_host}/${_port}\"" \
  "ssh ${ssh_opt} ${_host} -p ${_port} exit 0")

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: InitRemoteEnv()
#
# Description:
#   Initialization of the remote environment.
#
# Usage:
#   InitRemoteEnv
#
# Examples:
#   InitRemoteEnv
#

function InitRemoteEnv() {

  local _FUNCTION_ID="InitRemoteEnv"
  local _STATE=0

  _sprintf "head" "preparing configuration of remote environment"

  _logger "head" \
    "${_FUNCTION_ID}()" \
    "preparing configuration of remote environment"

  _msg_args+=(\
  "src: '${_pv_xen_vars}'" \
  "src: '${_pv_vmware_vars}'" \
  "src: '${_pv_vmware_disks}")

  _cmd_args+=(\
  "ssh ${ssh_opt} ${hv_host} -p ${hv_port} >${_pv_xen_vars}" \
  "ssh ${ssh_opt} ${hv_host} -p ${hv_port} >${_pv_vmware_vars}" \
  "ssh ${ssh_opt} ${hv_host} -p ${hv_port} >${_pv_vmware_disks}")

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: CheckRemoteEnv()
#
# Description:
#   Checks of the remote environment.
#
# Usage:
#   CheckRemoteEnv
#
# Examples:
#   CheckRemoteEnv
#

function CheckRemoteEnv() {

  local _FUNCTION_ID="CheckRemoteEnv"
  local _STATE=0

  _sprintf "head" "checking configuration of remote environment"

  _logger "head" \
    "${_FUNCTION_ID}()" \
    "checking configuration of remote environment"

  if [[ "$hv_type" == "xen" ]] ; then

    _msg_args+=(\
    "vm id: '${vm_id}'" \
    "directory: '${hv_storage}'")

    _cmd_args+=(\
    "ssh ${ssh_opt} ${hv_host} -p ${hv_port} if [[ ! \$(xe vm-list | grep ${vm_id}) ]] ; then exit 1 ; fi" \
    "ssh ${ssh_opt} ${hv_host} -p ${hv_port} if [[ ! -d \"${hv_storage}\" ]] ; then exit 1 ; fi")

  elif [[ "$hv_type" == "vmware" ]] ; then

    _msg_args+=(\
    "vm id: '${vm_id}'" \
    "vm directory: '${re_path}'")

    _cmd_args+=(\
    "ssh ${ssh_opt} ${hv_host} -p ${hv_port} if [[ ! \$(vim-cmd vmsvc/getallvms | grep ${vm_id}) ]] ; then exit 1 ; fi" \
    "ssh ${ssh_opt} ${hv_host} -p ${hv_port} if [[ ! -d \"${re_path}\" ]] ; then exit 1 ; fi")

  fi

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: GetRemoteEnv()
#
# Description:
#   Dump of the remote environment to local.
#
# Usage:
#   GetRemoteEnv
#
# Examples:
#   GetRemoteEnv
#

function GetRemoteEnv() {

  local _FUNCTION_ID="GetRemoteEnv"
  local _STATE=0

  _sprintf "head" "downloading configuration of remote environment"

  _logger "head" \
    "${_FUNCTION_ID}()" \
    "downloading configuration of remote environment"

  if [[ "$hv_type" == "vmware" ]] ; then

    _msg_args+=(\
    "vmx configuration search" \
    "vmdk disk search" \
    "get src: '$_pv_vmware_vars'" \
    "get src: '$_pv_vmware_disks'")

    _cmd_args+=(\
    "ssh ${ssh_opt} ${hv_host} -p ${hv_port} cd \"${re_path}\" && find . -name \"*.vmx\" >> ${_pv_vmware_vars}" \
    "ssh ${ssh_opt} ${hv_host} -p ${hv_port} cd \"${re_path}\" && find . -name \"*.vmdk\" >> ${_pv_vmware_disks}" \
    "scp ${ssh_opt} -P ${hv_port} ${hv_host}:${_pv_vmware_vars} ${_pv_vmware_vars}" \
    "scp ${ssh_opt} -P ${hv_port} ${hv_host}:${_pv_vmware_disks} ${_pv_vmware_disks}")

  fi

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: VmExport()
#
# Description:
#   Exports the virtual machine.
#
# Usage:
#   VmExport
#
# Examples:
#   VmExport
#

function VmExport() {

  local _FUNCTION_ID="VmExport"
  local _STATE=0

  _sprintf "head" "exporting $vm_id"

  _logger "info" \
    "${_FUNCTION_ID}()" \
    "exporting $vm_id"

  _msg_args+=(\
  "creating snapshot: '${vm_name}-${_random}'" \
  "exporting snapshot: '${vm_name}.ova'")

  _cmd_args+=(\
  "ssh ${ssh_opt} ${hv_host} -p ${hv_port} _id=\$(xe vm-snapshot vm=${vm_id} new-name-label=${vm_name}-${_random}) ; echo \$_id >> ${_pv_xen_vars}" \
  "ssh ${ssh_opt} ${hv_host} -p ${hv_port} _id=\$(cat ${_pv_xen_vars}) ; xe vm-export vm=\${_id} filename=${hv_storage}/${vm_name}.ova")

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: VmCopy()
#
# Description:
#   Copies the virtual machine from remote host to local (target) host.
#
# Usage:
#   VmCopy
#
# Examples:
#   VmCopy
#

function VmCopy() {

  local _FUNCTION_ID="VmCopy"
  local _STATE=0

  _sprintf "head" "copying a virtual machine stack"

  _logger "info" \
    "${_FUNCTION_ID}()" \
    "copying a virtual machine stack"

  local _fvmx
  local _fda

  _sprintf "info" "set directory: '$lo_path'"

  cd "$lo_path" || \
  _logger "stop" \
    "${_FUNCTION_ID}()" \
    "directory change error: '$lo_path'"

  if [[ "$hv_type" == "xen" ]] ; then

    _msg_args+=(\
    "checking: '${vm_name}.ova'" \
    "get src: '${vm_name}.ova'")

    _cmd_args+=(\
    "ssh ${ssh_opt} ${hv_host} -p ${hv_port} if [[ ! -e \"${hv_storage}/${vm_name}.ova\" ]] ; then exit 1 ; fi" \
    "scp ${ssh_opt} -P ${hv_port} ${hv_host}:${hv_storage}/${vm_name}.ova ${lo_path}")

  elif [[ "$hv_type" == "vmware" ]] ; then

    _fvmx=$(grep ".vmx" "$_pv_vmware_vars" | cut -d "/" -f2)

    _msg_args+=(\
    "checking: '${_fvmx}'" \
    "get src: '${_fvmx}'")

    _cmd_args+=(\
    "ssh ${ssh_opt} ${hv_host} -p ${hv_port} if [[ ! -e \"${re_path}/${_fvmx}\" ]] ; then exit 1 ; fi" \
    "scp ${ssh_opt} -P ${hv_port} ${hv_host}:${re_path}/${_fvmx} ${lo_path}")

    # Issue to solve:
    # shellcheck disable=SC2013
    _fname=""
    for _fname in $(grep ".vmdk" "$_pv_vmware_disks" | cut -d "/" -f2) ; do

      _fda="$_fname"

      _msg_args+=(\
      "checking: '${_fda}'" \
      "get src: '${_fda}'")

      _cmd_args+=(\
      "ssh ${ssh_opt} ${hv_host} -p ${hv_port} if [[ ! -e \"${re_path}/${_fda}\" ]] ; then exit 1 ; fi" \
      "scp ${ssh_opt} -P ${hv_port} ${hv_host}:${re_path}/${_fda} ${lo_path}")

    done

  fi

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: VmExtract()
#
# Description:
#   Extracts the virtual machine disks.
#
# Usage:
#   VmExtract
#
# Examples:
#   VmExtract
#

function VmExtract() {

  local _FUNCTION_ID="VmExtract"
  local _STATE=0

  _sprintf "head" "extracting ova files"

  _logger "info" \
    "${_FUNCTION_ID}()" \
    "extracting ova files"

  _sprintf "info" "set directory: '$lo_path'"

  cd "$lo_path" || \
  _logger "stop" \
    "${_FUNCTION_ID}()" \
    "directory change error: '$lo_path'"

  _msg_args+=(\
  "checking: '${vm_name}.ova'" \
  "src: '${vm_name}.ova'")

  _cmd_args+=(\
  "eval if [[ ! -e ${vm_name}.ova ]] ; then exit 1 ; fi" \
  "tar xf ${vm_name}.ova -C ${lo_path}")

  # shellcheck disable=SC2154
  if [[ "$remove_unused" == "yes" ]] ; then

    _msg_args+=(\
    "remove: '${vm_name}.ova'")

    _cmd_args+=(\
    "rm -fr ${vm_name}.ova")

  fi

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: VmConvertDisks()
#
# Description:
#   Converts the virtual machine disks.
#
# Usage:
#   VmConvertDisks
#
# Examples:
#   VmConvertDisks
#

function VmConvertDisks() {

  local _FUNCTION_ID="VmConvertDisks"
  local _STATE=0

  _sprintf "head" "converting disks to $pve_format format"

  _logger "info" \
    "${_FUNCTION_ID}()" \
    "converting disks to $pve_format format"

  local _fdx
  local _fda
  local _fdb
  local _fdc

  local _fvmx
  local _x=1

  _sprintf "info" "set directory: '$lo_path'"

  cd "$lo_path" || \
  _logger "stop" \
    "${_FUNCTION_ID}()" \
    "directory change error: '$lo_path'"

  if [[ "$hv_type" == "xen" ]] ; then

    # Issue to solve:
    # shellcheck disable=SC2044
    _fname=""
    for _fname in $(find ./* -type d -name "Ref:*" | cut -d "/" -f2) ; do

      # Store directory name (eg. Ref:20).
      _fdx="$_fname"

      # Store new directory/file name (eg. Ref_20).
      _fda=$(echo "$_fdx" | tr ":" "_")

      # Store new 'img' file (eg. 1-Ref_20.img).
      _fdb="${_x}-${_fda}.img"

      _msg_args+=(\
      "checking: '${_fdx}'" \
      "src: '${_fdx}', dst: '${_fdb}'")

      _cmd_args+=(\
      "eval if [[ ! -d ${_fdx} ]] ; then exit 1 ; fi" \
      "xenmigrate --convert=${_fdx} ${_fdb}")

      if [[ "$remove_unused" == "yes" ]] ; then

        _msg_args+=(\
        "remove: '${_fdx}'")

        _cmd_args+=(\
        "rm -fr ${_fdx}")

      fi

      if [[ "$pve_format" == "qcow2" ]] ; then

        # Store 'qcow2' file name (eg. 1-Ref_20.qcow2).
        _fdc="${_fdb%.*}.qcow2"

        _msg_args+=(\
        "checking: '${_fdb}'" \
        "src: '${_fdb}', dst: '${_fdc}'")

        _cmd_args+=(\
        "eval if [[ ! -e ${_fdb} ]] ; then exit 1 ; fi" \
        "qemu-img convert -f raw -O qcow2 ${_fdb} ${_fdc}")

        if [[ "$remove_unused" == "yes" ]] ; then

          _msg_args+=(\
          "remove: '${_fdb}'")

          _cmd_args+=(\
          "rm -fr ${_fdb}")

        fi

      fi

    _x=$((_x + 1))

    done

  elif [[ "$hv_type" == "vmware" ]] ; then

    _fvmx=$(grep ".vmx" "$_pv_vmware_vars" | cut -d "/" -f2)

    # Issue to solve:
    # shellcheck disable=SC2013
    _fname=""
    for _fname in $(grep ".vmdk" "$_pv_vmware_disks" | cut -d "/" -f2) ; do

      # Store 'vmdk' file name (eg. vm.vmdk).
      _fdx="$_fname"

      # Store file name without extension (eg. vm).
      _fda=${_fname%.*}

      if [[ "$_fdx" != *"flat"* ]] ; then

        if [[ "$pve_format" == "qcow2" ]] ; then

          # Store 'qcow2' file name (eg. 1-vm.qcow2).
          _fdb="${_x}-${_fdx%.*}.qcow2"

          _msg_args+=(\
          "checking: '${_fdx}'" \
          "src: '${_fdx}', dst: '${_fdb}'")

          _cmd_args+=(\
          "eval if [[ ! -e ${_fdx} ]] ; then exit 1 ; fi" \
          "qemu-img convert -f vmdk -O qcow2 ${_fdx} ${_fdb}")

        elif [[ "$pve_format" == "img" ]] ; then

          # Store 'img' file name (eg. 1-vm.img).
          _fdb="${_x}-${_fdx%.*}.img"

          _msg_args+=(\
          "checking: '${_fdx}'" \
          "src: '${_fdx}', dst: '${_fdb}'")

          _cmd_args+=(\
          "eval if [[ ! -e ${_fdx} ]] ; then exit 1 ; fi" \
          "qemu-img convert -f vmdk -O raw ${_fdx} ${_fdb}")

        fi

        if [[ "$remove_unused" == "yes" ]] ; then

          _msg_args+=(\
          "remove: '${_fdx}'")

          _cmd_args+=(\
          "rm -fr ${_fdx}")

          if [[ -e "${_fda}-flat.vmdk" ]] ; then

            _msg_args+=(\
            "remove: '${_fda}-flat.vmdk")

            _cmd_args+=(\
            "rm -fr ${_fda}-flat.vmdk")

          fi

        fi

        _x=$((_x + 1))

      fi

    done

  fi

  if [[ -e "${_fvmx}" ]] ; then

    _msg_args+=(\
    "remove: '${_fvmx}'")

    _cmd_args+=(\
    "rm -fr ${_fvmx}")

  fi

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: VmImport()
#
# Description:
#   Imports the virtual machine.
#
# Usage:
#   VmImport
#
# Examples:
#   VmImport
#

function VmImport() {

  local _FUNCTION_ID="VmImport"
  local _STATE=0

  _sprintf "head" "importing a virtual machine disks"

  _logger "info" \
    "${_FUNCTION_ID}()" \
    "importing a virtual machine disks"

  local _x=1

  _sprintf "info" "set directory: '$lo_path'"

  cd "$lo_path" || \
  _logger "stop" \
    "${_FUNCTION_ID}()" \
    "directory change error: '$lo_path'"

  _fname=""
  for _fname in $(find ./* -type f -name "*.$pve_format" | cut -d "/" -f2 | sort -V) ; do

    _fda="$_fname"

    _msg_args+=(\
    "checking: '${_fda}'")

    _cmd_args+=(\
    "eval if [[ ! -e ${_fda} ]] ; then exit 1 ; fi")

    if [[ "$pve_format" == "img" ]] ; then

      local _vm_pv_local="${pve_lvm}/vm-${pve_id}-disk-${_x}"

      if [[ "$pve_host" == "local" ]] ; then

        _msg_args+=(\
        "checking: '${_vm_pv_local}'" \
        "src: '${_fda}', dst path: '${_vm_pv_local}'")

        _cmd_args+=(\
        "eval if [[ ! -e ${_vm_pv_local} ]] ; then exit 1 ; fi" \
        "dd if=${_fda} of=${_vm_pv_local} ${dd_opt}")

      elif [[ "$pve_host" != "local" ]] ; then

        _msg_args+=(\
        "checking: '${pve_host}:${_vm_pv_local}'" \
        "src: '${_fda}', dst path: '${pve_host}:${_vm_pv_local}'")

        _cmd_args+=(\
        "ssh ${ssh_opt} ${pve_host} -p ${hv_port} if [[ ! -e \"${_vm_pv_local}\" ]] ; then exit 1 ; fi" \
        "eval dd if=${_fda} ${dd_opt} | ssh ${ssh_opt} ${pve_host} -p ${hv_port} dd of=${_vm_pv_local} ${dd_opt}")

      fi

      if [[ "$remove_unused" == "yes" ]] ; then

        _msg_args+=(\
        "remove: '${_fda}'")

        _cmd_args+=(\
        "rm -fr ${_fda}")

      fi

    elif [[ "$pve_format" == "qcow2" ]] ; then

      local _vm_pv_local="${pv_path}/vm-${pve_id}-disk-${_x}.qcow2"

      if [[ "$pve_host" == "local" ]] ; then

        _msg_args+=(\
        "checking: '${_vm_pv_local}'" \
        "src: '${_fda}'")

        _cmd_args+=(\
        "eval if [[ ! -e ${_vm_pv_local} ]] ; then exit 1 ; fi" \
        "cp ${_fda} ${_vm_pv_local}")

      elif [[ "$pve_host" != "local" ]] ; then

        _msg_args+=(\
        "checking: '${pve_host}:${_vm_pv_local}'" \
        "src: '${_fda}'")

        _cmd_args+=(\
        "ssh ${ssh_opt} ${pve_host} -p ${hv_port} if [[ ! -e \"${_vm_pv_local}\" ]] ; then exit 1 ; fi" \
        "scp ${ssh_opt} ${_fda} -P ${hv_port} ${pve_host}:${_vm_pv_local}")

      fi

      if [[ "$remove_unused" == "yes" ]] ; then

        _msg_args+=(\
        "remove: '${_fda}'")

        _cmd_args+=(\
        "rm -fr ${_fda}")

      fi

    fi

    _x=$((_x + 1))

  done

  return $_STATE

}
